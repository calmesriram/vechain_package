/// <reference types="@vechain/connex" />
/// <reference types="@vechain/connex.driver" />
import { Net } from './interfaces';
/** class implements Connex.Driver leaves out Vendor related methods */
export declare class DriverNoVendor implements Connex.Driver {
    private readonly net;
    readonly genesis: Connex.Thor.Block;
    head: Connex.Thor.Status['head'];
    private headResolvers;
    private readonly int;
    private readonly cache;
    constructor(net: Net, genesis: Connex.Thor.Block, initialHead?: Connex.Thor.Status['head']);
    close(): void;
    pollHead(): Promise<{
        id: string;
        number: number;
        timestamp: number;
        parentID: string;
        txsFeatures?: number | undefined;
    }>;
    getBlock(revision: string | number): Promise<Connex.Thor.Block | null>;
    getTransaction(id: string): Promise<Connex.Thor.Transaction | null>;
    getReceipt(id: string): Promise<Connex.Thor.Receipt | null>;
    getAccount(addr: string, revision: string): Promise<Connex.Thor.Account>;
    getCode(addr: string, revision: string): Promise<any>;
    getStorage(addr: string, key: string, revision: string): Promise<any>;
    explain(arg: Connex.Driver.ExplainArg, revision: string, cacheTies?: string[]): Promise<any>;
    filterEventLogs(arg: Connex.Driver.FilterEventLogsArg): Promise<any>;
    filterTransferLogs(arg: Connex.Driver.FilterTransferLogsArg): Promise<any>;
    signTx(msg: Connex.Driver.SignTxArg, option: Connex.Driver.SignTxOption): Promise<Connex.Driver.SignTxResult>;
    signCert(msg: Connex.Driver.SignCertArg, options: Connex.Driver.SignCertOption): Promise<Connex.Driver.SignCertResult>;
    isAddressOwned(addr: string): Promise<boolean>;
    protected httpGet(path: string, query?: Record<string, string>): Promise<any>;
    protected httpPost(path: string, body: any, query?: Record<string, string>): Promise<any>;
    private readonly headerValidator;
    private emitNewHead;
    private headTrackerLoop;
    private trackWs;
}
